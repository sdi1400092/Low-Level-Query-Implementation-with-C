Project 
Φοιτητες: Αντώνιος Μαζέρας 1115201400092 | Χρήστος-Ιωάννης Μάλλιος 1115201900106

Δομές που χρησιμοποιήθηκαν:

**Δεν αλλάχθηκαν από την εκφώνηση:
    tuple
    relation

**Δημιουργηθηκαν από εμάς:
    Hist
    bucket
    HT_bucket
    HT
    rela (δομή για την αναπαράσταση των σχέσεων στα ερωτήματα)
    query (δομή για την αναπαράσταση ενος κατηγορήματος)
    predicate (δομή για την αναπαράσταση των κατηγορημάτων στα ερωτήματα)
    sums (δομή για την αναπαράσταση των προβολών στα ερωτήματα)
    Στο struct result προσθέσαμε και δυο μέλη (int *conto, int num_of_conto), τα οποία 
        αναπαριστούν για ενα πίνακα των αριθμό των συνδέσεων με άλλους πίνακες, σε άλλα ερωτήματα
        καθώς και ενα δείκτη σε κάθε πίνακα που συνδέεται με αυτόν σε κάποιο άλλο ερώτημα.

Βοηθητικές συναρτήσεις:
    Binary -> μετατροπή ενός αριθμού σε δυαδική μορφή
    power -> εκτελεση της πραξης base^exp

Συναρτήσεις για την υλοποιηση της εργασιας:
    Partition -> δεχεται ως ορισμα εναν πινακα και ενα δεικτη σε ενα κενο ιστογραμμα καθως και ενα αριθμο 
                n που είναι τα σημαντικα ψηφια. δημιουργει 2^n "buckets" για να αποθηκευσει προσωρινα τους 
                αριθμους. στη συνεχεια καλει την Binary και με τη βοηθεια της βρισκει σε ποιο bucket
                αντιστοιχει ο αριθμος αυτος και τον τοποθετει και ενημερωνει και το ιστογραμμα καθε φορα
                Μολις τελειωσει, επιστρεφει τα στοιχεια των bucket στον αρχικο πινακα πλεον "ταξινομημενα"
    Hopscotch -> ειναι η συναρτηση υπευθυνη για την "τακτοποιηση" των στοιχειων στο hashtable. Παιρνει ως
                ως ορισματα, ενα δεικτη στο hashtable το payload του στοιχειου το hash value του το rowid 
                του καθως και το μηκος του hashtable. στην αρχη εξεταζει το ενδεχωμενο να βρισκεται ηδη
                καποιο στοιχειο με το ιδιο hash value αλλα να ειχαν και ιδιο αρχικο payload οποτε αυξανει 
                τον πινακα των rowid κατα 1 και προσθετει στο τελος του το καινουργιο στοιχειο. Σε περιπτωση
                που δεν βρει το ιδιο payload αλλα ολα τα bucket της γειτονιας εχουν bitmap 1, δηλαδη ειναι 
                γεμάτα, σημαινει οτι η γειτονια εχει ηδη γεμισει και χρειαζεται rehash. επισης 
                εξεταζει και ολη τη γειτονια του bucket αυτου σε περιπτωση που εχει προηγηθει ολισθηση.
                Εαν δεν υπαρχει ηδη. Εξεταζει εαν το bucket που του αντιστοιχει είναι αδειο και εαν ειναι 
                το τοποθετει εκει. Εαν δεν ειναι εξεταζει την γειτονια του και εαν βρει κενο bucket σε αυτη
                τοποθετειται εκει. Εαν δεν υπαρχει στη γειτονια του κενο bucket, ψαχνει το πρωτο κενο bucket
                εκτος γειτονιας. Οταν το βρει προσπαθει να κανει ολισθηση τα bucket αριστερα απο αυτο μεχρι
                να δημιουργηθει κενη θεση εντος γειτονιας του bucket που προοριζοταν αρχικα το στοιχειο μας
                Σε περιπτωση που δεν βρει κενο ή δεν μπορει να κανει ολισθηση buckets αρκετα ωστε να δημιου-
                ργηθει κενο στη γειτονια που θελουμε επιστρεφει -1 που σημαινει οτι χρειαζεται rehash.
    Hashing -> Μια απλη hash function που παιρνει εναν αριθμο(payload) και ένα μεγεθος(len) και επιστρεφει
                το υπολοιπο της διαιρεσης
    HashTableFunction -> Η συναρτηση αυτη δημιουργει και επιστρεφει το hashtable. αρχικα το αρχικοποιει,
                        μετά για καθε στοιχειο του partition για το οποιο καλεστηκε βρισκει το hash value 
                        του και καλει για αυτο την Hopscotch σε περιπτωση που η hopscotch επιστρεψει -1 
                        διπλασιαζει το μηκος του hashtable και ξανακαλει αναδρομικα τον εαυτο της εαν 
                        εαν επιστρεψει 0 συνεχιζει στο επομενο στοιχειο του partition.
    Probe -> Μια συναρτηση που παιρνει για ορισματα ενα hashtable τον πινακα S και την αρχη και το τελος
            του καθε partition του S για το οποιο καλεστηκε. Η συναρτηση αυτη για καθε στοιχειο του 
            partition του S βρισκει το hash value του και στη συνεχεια ψαχνει στο hashtable το bucket που 
            του αναλογει αλλα και τη γειτονια του μεχρι να βρει ΗΙΤ εαν βρει κανει break και συνεχιζει στο
            επομενο στοιχειο του S. Η Probe τα αποτελεσματα της τα γραφει στο αρχειο που δημιουργει το 
            results.txt
    PartitionedHashJoin -> αυτη η συναρτηση απλά ελεγχει αν ο καθε πινακας χωραει μεσα στην L2 cache και
                            αν δεν χωραει καλει την partition. στη συνεχεια δημιουργει τα αντιστοιχα ιστο-
                            γραμματα και καλει την HashTableFunction για καθε ενα απο αυτα και ταυτοχρονα
                            και την Probe.


Για την εκτελεση του προγραμματος μας τρεχουμε γραφουμε make στο command line και στη συνεχεια make run 
και τα αποτελεσματα βρισκονται στο αρχειο results.txt . Για να αλλαξουμε τα αρχεια που ανοιγει ο Parser
για να βγαλει τους πινακες παμε στο makefile και αλλαζουμε το ονομα τους απο το parameter. για να αλλαξουμε
τις στηλες που διαβαζει ο Parser πηγαινουμε στη main και αλλαζουμε τις μεταβλητες columnR/columnS στα 
#define πανω πανω στο προγραμμα.


Version 2.0

    Mapping: Η συνάρτηση παίρνει ως όρισμα το αρχείο σε δυαδική μορφή και μέσω mmap 
        και με τις κατάλληλες αναθέσεις επιστρέφει στην main ενα struct τύπου relation
        οπου αναπαριστάται ο εκάστοτε πίνακας.

    ParseRelations: Επιστρέφει ενα struct rela με τα ονόματα και το πλήθος των πινάκων
                    για ενα ερώτημα
    
    ParsePredicates: παίρνει σαν όρισμα ενα κατηγόρημα και επιστρέφει μια δομή predicate 
                    που περιέχει τα μέρη ενος κατηγορήματος


    ParseProjections: Παίρνει σαν όρισμα τις προβολές ενος ερωτήματος και επιστρέφει
                    ενα struct με τα μέρη μια προβολής. Για κάθε πίνακα έχει και ενα 
                    πεδίο όπου αποθηκεύονται οι προβολές για τον συγκεριμένο.
    
    Compare: Μια συνάρτηση οπου εκτελεί τα κατηγορήματα φίλτρου

    updateResult: Μια συνάρτηση που παίρνει σαν ορίσματα τα new_res δηλαδη τα result του τελευταίου
    		  Join, τα old_res δηλαδη τα συνολικά result του επερωτήματος και x ενας
    		  ακέραιος που είναι το πλήθος των σχέσεων που έχει το επερώτημα. Βάζει στο
    		  temp τα new_res και στη συνέχεια εαν υπάρχει κάποιος πίνακας στα old_res 
    		  που είναι συνδεδεμένος σε κάποιο από τα 2 new_res τότε βρίσκει σύμφωνα 
    		  με τα new_res ποιά rowid του σενδεδεμένου πίνακα αντιστοιχούν στα rowid 
    		  του πιο προσφατου πίνακα από τα new_res. Εάν υπάρχει πίνακας στα old_res 
    		  αλλά δεν είναι συνδεδεμένος με κάποιον από τους πίνακες των new_res τότε
    		  τον βάζει στο temp ως έχει. Τέλος, επιστρέφει temp ως τον ενημερωμένο 
    		  πίνακα των αποτελεσμάτων. Σημειώνεται ότι στο temp, δηλαδή τον πίνακα, 
    		  που έχει μέγεθος x είτε έχουν λάβει χώρο όλοι οι πίνακες στα μέχρι τώρα 
    		  predicates είτε όχι, όσοι πίνακες δεν έχουν λάβει μέχρι στιγμής μέρος σε
    		  κάποιο predicate έχουν ως relnum(αριθμό σχέσης) = -1 αντί για 0, 1, 2,...
